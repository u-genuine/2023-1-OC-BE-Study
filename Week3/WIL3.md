# 1. 의존과 의존성
의존성은 코드에서 두 모듈간의 연결을 의미한다.  

클래스 A가 다른 클래스(혹은 인터페이스) B를 사용할 때 A는 B에 의존한다고 이야기한다. 즉, 한 객체의 코드에서 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 그리고 파라미터로 객체를 전달받아 사용할 때 의존성이 발생한다고 할 수 있다.  

이때, 모듈과 모듈사이의 의존성의 정도를 결합도(Coupling) 라고 한다. 결합도의 Loose 하고 Tight 한 정도는 연속적으로 표현된다. 즉, 이분법적으로 표현할 수 없다.  
***
## **의존성이 위험한 이유**
A가 B에 의존중일때, B의 변경은 A에게 영향을 끼친다. 즉, B의 변경이 A의 변경을 초래할 가능성이 존재한다. 이런 의존의 영향은 꼬리에 꼬리를 문 것 처럼 도미노같이 전파된다.  

예를 들어 A는 B에 의존하고, B는 C에 의존하고 있는 상황을 가정해보자. 이떄, C가 변경되면 B를 변경해야하고, 이어서 A를 변경해야 한다. 특히 이와 같은 문제는 순환 의존의 형태에서 심하게 발생될 수 있다. 앞서 말한 의존관계에서 추가로 C가 A에 의존하여 순환 의존을 하고 있다고 가정해보자. 그런 상황에서 C의 변경은 다시 C 자기자신에게까지 영향을 미칠 수 있다.  

그리고 의존성은 유닛 테스트가 어려운 코드를 만든다. 유닛 테스트는 '특정 모듈'이 의도된대로 작동하는 지 테스트하는 과정을 의미하는데, 특정 모듈의 작동이 다른 모듈을 필요로 한다면, 즉 의존관계가 있다면 특정 모듈만을 독립적으로 떼어내어 테스트하기 어렵다.

또한 과도한 의존성은 모듈을 재사용 어렵게 만든다.

# 2. @Autowired 의존성 주입
스프링에는 다양한 의존 주입 방법이 있다.  
대표적으로 생성자 주입, setter 주입, 필드 주입 이렇게 3가지가 있다.

### **1. 생성자 주입**
스프링 컨테이너가 올라오고 어플리케이션이 setting이 되는 시점에 생성자 주입을 통해 한번만 호출 되는것이 보장되어 '불변, 필수' 의존관계이서 사용된다.

### **2. setter 주입**
set이 public하게 노출이 될 경우 setter가 실행되어 변경될 수 있는 문제점이 있다.  
하지만, 변경 가능성이 있는 의존관계에서는 사용할 필요가 있다.  
### **3. 필드 주입**
필드에 @Autowired 어노테이션을 붙이는 방법이다. 중간에 외부에서 변경이 불가능하기 때문에 테스트하기 힘들다는 단점이 있다.

***

## **@Autowired란?**
@Autowired은 의존성 주입(DI, Dependency Injection)을 할 때 사용하는 Annotation으로 의존 객체 **타입**에 해당하는 bean을 찾아 주입하는 역할을 한다.

@Autowired는 기본적으로 생성자, Setter, 필드 이렇게 세 위치에서 사용할 수 있다.  
IoC 컨테이너가 빈으로 등록을 해주기 때문에, 빈으로 등록되어있는 것들은 autowired로 꺼낼 수 있다.  



# 3. DIP 
DIP(Dependency Inversion Principle)의 핵심은 의존 관계를 맺을 때 **변화하기 쉬운 것에 의존하기 보다는 변화하지 않는 것에 의존**하라는 원칙이다.  

즉, 어떤 객체에서 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하는 것이 아니라 그 **대상의 상위요소(추상클래스 or 인터페이스)로 참조**하라는 원칙이다.  

객체들이 서로 정보를 주고받을 때는 의존 관계가 형성되는데, 이 때 객체들은 나름대로의 원칙을 갖고 주고받아야 약속이 있다. 여기서 나름대로의 원칙이란, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 통신을 한다는 것을 의미하는데 이것이 DIP 원칙이다.  

다시 말하면 클라이언트(사용자)가 상속관계로 이루어진 모듈을 가져다 사용할 때, **하위 모듈 인스턴스를 직접 가져다 쓰지 말라**는 뜻이다. 왜냐하면 그렇게 할 경우, 하위 모듈의 구체적인 내용에 클라이언트가 의존하게 되어 하위 모듈에 변화가 있을 때마다 **클라이언트나 상위 모듈의 코드를 자주 수정**해야 하기 때문이다.  

따라서 자신보다 변하기 쉬운 것에 의존하던것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다.  
상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이다.  

# 4. 스프링 빈과 스프링 컨테이너란?
## **스프링 컨테이너**
스프링 컨테이너는 스프링에서 자바 객체들을 관리하는 공간을 말한다. 자바 객체를 스프링에선 빈(Bean)이라고 하는데, 스프링 컨테이너에는 이 빈의 생성부터 소멸까지를 개발자 대신 관리해주는 곳이라고 할 수 있다.  

컨테이너는 크게 두 종류로 나눌 수 있다. 하나는 BeanFactory이고, 다른 하나는 ApplicationContext 이다. ApplicationContext 컨테이너가 BeanFactory의 기능을 포괄하면서 추가적인 기능을 제공하기 때문에, 대부분의 경우에는 ApplicationContext를 사용한다.  

스프링 컨테이너에 객체, 빈을 등록하는 이유는 스프링이 각 객체간 의존관계를 관리하도록 하는데에 큰 목적이 있다. 객체가 의존관계를 등록할 때는 스프링 컨테이너에서 해당하는 빈을 찾고, 그 빈과 의존성을 만든다.
***
## **스프링 빈**
스프링은 보통의 경우 스프링 컨테이너에 빈 인스턴스를 단 한개만 저장하는 싱글톤 방식을 채택하고 있다. 빈 이름은 항상 다르게 지정이 되어야 한다. 예상치 못한 여러 오류가 발생하는데, 이를 개발 중 발견하기 매우 어렵기 떄문이다. 스프링 빈을 등록하는 방법은 크게 2가지로 나뉜다.   

### **1. 컴포턴트 스캔**
@Component Annotation을 통해 가능한데, 이 외에도 스프링 프레임워크에서 제공하는 @Controller나 @Service 혹은 @Repository와 같은 Annotation은 인터페이스로 @Component Annotation을 받기 때문에 컴포넌트 등록이 가능하다.  
단, 실행되는 패키지와 같은 패키지에 있는 클래스에 대해서만 @Component Annotation이 적용된다.  

### **2. 스프링 빈 직접 등록**
스프링 빈을 직접 등록하는 것은 @Configuration과 @Bean Annotation으로 가능하다.
***
## **빈 관련 메서드**
ApplicationContext 타입의 변수를 ac라고 가정하고, ac.메서드명 형태로 아래 메서드들을 사용해야 한다.  

**getBeanDefinitionNames()**  
스프링에 등록된 모든 빈 이름을 조회한다.

**getBean()**  
특정 스프링 빈을 조회하는 데 사용된다. 매개변수로 여러 종류가 올 수 있다.
* ac.getBean(class 타입)
* ac.getBean(빈 이름, class 타입)
* ac.getBean(빈 이름)  

조회하고자 하는 빈이 존재하지 않으면 NoSuchBeanDefinitionExceotion 예외가 발생한다.  

**BeanDefinition.getRole()**
빈의 역할을 출력한다. 빈의 역할은 크게 두가지로 나뉜다. 하나는 스프링이 내부의 동작을 위해 사용하는 ROLE_INFRASTRUCTURE, 다른 하나는 사용자가 정의한 빈인 ROLE_APPLICATION이다.  

**getBeansOfType()**
해당 타입에 해당하는 모든 빈을 조회할 수 있다.


# 5. JDBC와 JPA?
## **영속성(Persistence)**
영속성이란 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성이다.  
**Persistence Layer**는 프로그램 아키텍처에서 데이터에 영속성을 부여해주는 계층을 말하는데, Persistence framework를 주로 이용한다.  
**Persistence framework**는 JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발할 수 있고 안정적인 구동을 보장한다. Persistence framework는 크게 SQK Mapper와 ORM으로 나눌 수 있다.

## **SQL Mapper**
SQL Mapper는 SQL query문을 통해 직접 데이터베이스 데이터를 다루는 것으로 MYbatis와 JdbcTemplate가 있다.  
## **ORM**
ORM은 데이터베이스 객체를 자바 객체로 매핑함으로써 객체 간의 관계를 바탕으로 SQL을 자동으로 생성해준다. 즉, SQL query문을 작성할 필요가 없으며 객체 중심 개발이 가능하다.  
***
## **JDBC**
JDBC는 DB에 접근할 수 있도록 Java에서 제공하는 API로 Plain JDBC와 Spring JDBC가 있다.  
Spring JDBC 접근 방법 중 한로 많이 사용되는 JdbcTemplate를 사용할 경우 핵심 로직에 집중할 수 있다는 장점이 있다.  

**Plain JDBC의 문제점**
1. 쿼리 실행 전과 후에 많은 코드를 작성해야 한다.
2. 데이터베이스 로직에서 예외 처리 코드를 수행해야 한다.
3. 트랜잭션을 처리해야 한다.
4. 이러한 모든 코드를 반복하기 때문에 비효율적이다.

**그렇다면 JdbcTempate를 사용하면 어떻게 달라질까?**  

Spring JDBC가 Connection 열고 닫기, 예외 처리와 트랜잭션 처리를 해주기 때문에 개발자는 datasource 설정, SQL 작성, 결과 처리 수행에만 집중할 수 있어 Plan Jdbc에 비해 코드가 훨씬 간결해진 것을 확인할 수 있다.  

코드가 간결해졌음에도 불구하고 SQL query문을 작성해야 하기 때문에 객체 지향 개발이 어렵다는 단점이 있다. 이를 해결하기 위해 JPA가 등장한다.  

## **JPA**
JPA는 자바 ORM 기술에 대한 표준 명세로 Java에서 제공하는 API이다. 즉, ORM을 사용하기 위한 표준 인터페이스를 모아둔 것으로 대표적인 구현체로는 Hibernate가 있다.  
EntityManager를 통해 엔티티를 영속성 컨텍스트에 저장하고 객체와 테이블을 매핑하여 객체 지향 개발이 가능하다는 특징이 있다.  

JPA를 사용할 경우 많은 장점이 있지만 어렵고 제대로 사용하지 않을 경우 데이터 손실이 있다는 단점이 있다.
