## **IoC와 프레임워크, 라이브러리**

### **제어의 역전(IoC)**

제어의 역전(Inversion of Control)은 하나의 **설계원칙**이고, 디자인 패턴이라고도 한다.

프로그래머가 직접 객체의 생성, 소멸, 객체간 관계같은 객체의 제어를 수행하는 것이 아니라, 여러 **프레임워크, 컨테이너에서 제어를 수행하는 것**이다.

확장 가능하고 모듈화된 프로그램을 구성하는 느슨한 결합을 달성하기 위해 다양한 종류의 컨트롤을 반전하는 것을 의미한다.

여기에는 응용 프로그램의 흐름에 대한 제어와 개체 생성 또는 종속 개체 생성 및 바인딩 흐름에 대한 제어가 포함된다.

이러한 제어의 역전은 클래스간의 결합을 느슨하게 설계하여 테스트가 가능하고 유지보수가 용이하게 만드는데 도움이 된다.

### **프레임워크**

프레임워크는 애플리케이션 개발 시 필수적인 코드, 알고리즘, DB 커넥션 등의 기능을 위해 뼈대를 제공한다. 개발자는 이러한 뼈대 위에서 코드를 작성해 원하는 애플리케이션을 개발할 수 있다.

프레임워크는 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 상호협력하는 클래스와 인터페이스의 집합이라고 할 수 있다.

예를 들어 Java 개발에서 사용되는 Spring 프레임워크나 Python 개발에 사용되는 Django, 안드로이드 앱개발에 사용되는 Android 등이 있다.

### **라이브러리**

라이브러리는 개발에 필요한 것들을 미리 구현해놓은 도구라고 할 수 있다. 재사용이 가능한 기능을 미리 구현해놓고 필요한 곳에서 호출하여 사용 가능하도록 만들어진 집합이다.

예를 들어 C++의

STL이나 Python의 Pip로 설치한 패키지/모듈(pandas, tensorflow 등)이 있다.

### **프레임워크와 라이브러리 차이**

프레임워크는 라이브러리를 포함한다. 프레임워크 위에 개발자가 작성한 애플리케이션 코드가 올라가게 되고, 이 애플리케이션 코드에서는 라이브러리를 호출할 수 있다.

프레임워크와 라이브러리의 가장 큰 차이점은 **제어 흐름이 어디에 있는가**이다.

프레임워크는 제어의 역전(IoC) 개념이 적용되어 있다. 즉, 프레임워크에게 제어의 흐름을 넘겨 개발자가 작성하는 코드에서 신경써야 할 부분을 줄인다는 뜻이다.

프레임워크는 전체적인 흐름을 쥐고 있으며 애플리케이션 코드는 프레임워크에 의해 사용된다. 애플리케이션 코드는 프레임워크가 짜놓은 틀 안에서 수동적으로 동작하기 때문에 제어의 흐름은 프레임워크에게 있다.

반면 라이브러리는 개발자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓰게 된다. 즉, 개발자에게 전적으로 제어흐름이 있으며 필요할 때마다 능동적으로 라이브러리를 호출하여 사용한다.

---

## **생성자를 통한 의존성 주입과 @Autowired 비교**

의존성 주입은 생성자 주입, 필드 주입, 수정자 주입의 3가지 방법이 있다.

**1. 생성자 주입**

클래스의 생성자가 하나이고, 그 생성자로 주입받을 객체가 빈으로 등록되어 있다면 @Autowired를 생략할 수 있다.

**2. 필드 주입**

필드에 @Autowired 어노테이션만 붙여주면 자동으로 의존성 주입이 된다. 사용법이 매우 간단하기 떄문에 가장 많이 접할 수 있는 방법이다.

코드가 간결하지만 외부에서 변경하기 힘들다는 것과 프레임워크에 의존적에고 객체지향적으로 좋지 않다는 **단점**이 있다.

**3. 수정자 주입**

Setter 메소드에 @Autowired 어노테이션을 붙이는 방법이다.

수정자 주입을 사용하면 setXXX메서드를 public으로 열어두어야 하기 때문에 언제 어디서든 변경이 가능하다는 단점이 있다.

### **가장 좋은 주입 방식**

Spring Framwork reference에서 권장하는 방법은 **생성자를 통한 주입**이다.

## **생성자 주입을 권장하는 이유**

**1. 순환 참조를 방지할 수 있다.**

개발을 하다보면 여러 컴포넌트 간에 의존성이 생기는데, 예를 들어 A가 B를 참조하고, B가 다시 A를 참조하는 순환 참조 코드가 있다고 가정한다.

필드 주입과 수정자 주입은 빈이 생성된 후에 참조를 하기 떄문에 어플리케이션이 아무런 오류와 경고 없이 구동되며, 이는 실제 코드가 호출될 때 까지 문제를 알 수 없다.

반면, 생성자를 통해 주입하고 실행하면 BeanCurrentlyCreationException이 발생한다. 순환 참조 뿐만 아니라 더 나아가 의존 관계에 내용을 외부로 노출시킴으로써 어플리케이션을 실행하는 시점에서 오류를 체크할 수 있다.

**2. 불변성**

생성자로 의존성을 주입할 때 final로 선언할수 있고, 이로 인해 런타임에서 의존성을 주입받는 객체가 변할 일이 없어지게 된다.

하지만 수정자 주입이나 일반 메소드 주입을 이용하게 되면 불필요하게 수정의 가능성을 열어두게 되고 이는 OOP 의 5가지 원칙 중 OCP를 위반하게 된다.

그러므로 생성자 주입을 통해 변경의 가능성을 배제하고 불변성을 보장하는 것이 좋다.  
또한, 필드 주입 방식은 null이 만들어질 가능성이 있는데, final로 선언한 생성자 주입 방식은 null이 불가능하다.

**3. 테스트에 용이하다**

생성자 주입을 사용하게 되면 테스트 코드를 좀 더 편리하게 작성할 수 있다.

독립적으로 인스턴스화가 가능한 POJO(Plain Old Java Object)를 사용하면, DI 컨테이너 없이도 의존성을 주입하여 사용할 수 있다.

이를 통해 코드 가독성이 높아지며, 유지보수가 용이하고 테스트의 격리성과 예측 가능성을 높일 수 있다는 장점이 생기게 된다.

위와 같은 이유로 필드 주입이나 수정자 주입 보다는 생성자 주입의 사용을 권장합니다.

---

## **AOP**

AOP는 Aspect Oriented Programming의 약자로 관점 지향 프로그래밍이라고 불린다. 관점 지향은 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 모듈화 하겠다는 것이다.

\*모듈화 : 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것

예를 들어 핵심적인 관점은 비즈니스 로직이 될 수 있고, 부가적인 관점은 핵심 로직을 실행하기 위해 행해지는 데이터베이스 연결, 로깅, 파일 입출력 등이 될 수 있다.

**AOP는 흩어진 관심사(Crosscutting Concerns)를 모듈화 할 수 있는 프로그래밍 기법이다.**
